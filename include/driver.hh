#pragma once

#include "file.hh"

#include <slang/ast/symbols/CompilationUnitSymbols.h>
#include <slang/ast/symbols/InstanceSymbols.h>
#include <slang/driver/Driver.h>

class Driver : public slang::driver::Driver {
public:
	Driver();

	void parse_cli(int argc, char *argv[]);

	/**
	 * @brief Prepares the file list for preprocessing and performs a
	 * preliminary compilation check.
	 *
	 * The preparation phase of the Nodo driver prepares the file list for the
	 * preprocessor passes. It also runs a preliminary compilation to verify
	 * that the pruned file list compiles properly.
	 *
	 * Processing is not terminated if the file list is invalid, but this may
	 * affect the final results if one or more files being pruned are part of
	 * the compilation hierarchy.
	 */
	void prepare();

	/**
	 * @brief Extracts macro-related metadata and file dependencies.
	 *
	 * The preprocessing phase consumes the file list generated by `prepare()`
	 * and extracts macro-related metadata for each file, including:
	 * - Exported macros
	 * - Unresolved macros
	 * - Included files
	 *
	 * After this phase, any macros not defined in the same compilation unit
	 * (i.e., the same file) OR are explicitly included are considered
	 * unresolved.
	 *
	 * Included files are added to each file's dependency list.
	 *
	 * If the command-line option `--debug-out-pfx <arg>` is set, the file
	 * `{arg}_preprocessed.log` will be created, containing a representation of
	 * the current state of node metadata.
	 */
	void preprocess();

	/**
	 * @brief Resolves module-based dependencies and unresolved macros.
	 *
	 * This pass uses the AST created in `prepare()` to amend the metadata
	 * created in `preprocess()` by including module-based dependencies in file
	 * dependency lists.
	 *
	 * Additionally, macros are resolved using the file dependency list. After
	 * this step, the only unresolved macros should be from files that:
	 * - Are not explicitly included
	 * - Do not include any modules used by the top module
	 * - Are defined via the command-line
	 *
	 * If the command-line option `--debug-out-pfx <arg>` is set, the file
	 * `{arg}_modules_resolved.log` will be created, containing a representation
	 * of the current state of node metadata.
	 *
	 * @return A shared pointer to the SourceNode that contains the top module.
	 */
	std::shared_ptr<SourceNode> module_resolution();

	/**
	 * @brief Resolves macros that are "implicitly" included, e.g., by source
	 * files being listed before this file in the compilation list.
	 *
	 * Macros can be implicitly resolved iff all of:
	 *   - A macro is left unresolved from previous preprocessing steps
	 *   - Where the macro has not been resolved via an include statement
	 *   - Where the macro has not been resolved by being included as part of a
	 *     module's dependency
	 *   - The macro definer is in a file explicitly listed in the file list
	 *   - The macro user is a file is later in the file list
	 *
	 * After this step, the only unresolved macros should be from files that:
	 * - Do not include any modules used by the top module
	 * - Are defined via the command-line
	 *
	 * If the command-line option `--debug-out-pfx <arg>` is set, the file
	 * `{arg}_resolved.log` will be created, containing a representation
	 * of the current state of node metadata.
	 */
	void implicit_macro_resolution();

	/**
	 * @brief To be run last.
	 *
	 * Produces the subset of files required to successfully compile the
	 * requested top module in reverse-topological order.
	 *
	 * @param result A reference to a container inside which the result is
	 *  emplaced.
	 *
	 * @param top_node A shared pointer to the SourceNode that contains the top
	 *  module.
	 *
	 * @exception std::runtime_error if a cycle is detected during the
	 * topological sort.
	 */
	void topological_sort(
		std::vector<std::filesystem::path> &result,
		std::shared_ptr<SourceNode> top_node
	);

private:
	// types
	enum class NodeState {
		unvisited = 0,
		visiting,
		visited,
	};
	struct ResolutionCacheEntry {
		NodeState state = NodeState::unvisited;
		std::set<std::string_view> resolved_macros;
	};
	struct Resolution {
		std::shared_ptr<SourceNode> file;
		std::set<std::string_view> resolved_macros;
	};
	struct FileEntry {};

	// methods

	Resolution process_included_macros_recursive(
		std::unordered_map<std::filesystem::path, ResolutionCacheEntry> &cache,
		std::shared_ptr<SourceNode> current_node
	);

	Resolution process_module_dependencies_recursive(
		std::unordered_map<std::filesystem::path, ResolutionCacheEntry> &cache,
		const slang::ast::InstanceSymbol *current_instance,
		int depth
	);
	Resolution
	process_module_dependencies(const slang::ast::InstanceSymbol *top_instance);

	inline std::pair<slang::SourceLocation, std::filesystem::path>
	get_definition_syntax_location(const slang::ast::InstanceSymbol &instance) {
		auto loc = instance.getDefinition().getSyntax()->sourceRange().start();
		auto path = sourceManager.getFullPath(loc.buffer());
		return std::make_pair(std::move(loc), std::move(path));
	}

	bool topological_sort_recursive(
		std::vector<std::filesystem::path> &result,
		std::unordered_map<std::filesystem::path, NodeState> &node_states,
		std::shared_ptr<SourceNode> target
	);

	// members
	std::unique_ptr<slang::ast::Compilation> compilation;
	std::unordered_map<std::filesystem::path, std::shared_ptr<SourceNode>>
		source_nodes;
	std::queue<std::pair<slang::SourceBuffer, size_t>>
		buffer_preprocessing_queue;

	// cli
	std::optional<bool> show_help;
	std::optional<bool> show_version;
	std::optional<std::string> debug_output_prefix_string;
};

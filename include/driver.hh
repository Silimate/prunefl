#pragma once

#include "file.hh"

#include <slang/ast/symbols/CompilationUnitSymbols.h>
#include <slang/ast/symbols/InstanceSymbols.h>
#include <slang/driver/Driver.h>

namespace nodo {
	class Driver : public slang::driver::Driver {
	public:
		Driver();

		void parse_cli(int argc, char *argv[]);

		/**
		 * @brief Prepares the file list for preprocessing and performs a
		 * preliminary compilation check.
		 *
		 * The preparation phase of the Nodo driver prepares the file list for
		 * the preprocessor passes. It also runs a preliminary compilation to
		 * verify that the pruned file list compiles properly.
		 *
		 * Processing is not terminated if the file list is invalid, but this
		 * may affect the final results if one or more files being pruned are
		 * part of the compilation hierarchy.
		 */
		void prepare();

		/**
		 * @brief Extracts macro-related metadata and file dependencies.
		 *
		 * The preprocessing phase consumes the file list generated by
		 * `prepare()` and extracts macro-related metadata for each file,
		 * including:
		 * - Exported macros
		 * - Unresolved macros
		 * - Included files
		 *
		 * After this phase, any macros not defined in the same compilation unit
		 * (i.e., the same file) OR are explicitly included are considered
		 * unresolved.
		 *
		 * Included files are added to each file's dependency list.
		 *
		 * If the command-line option `--debug-out-pfx <arg>` is set, the file
		 * `{arg}_preprocessed.log` will be created, containing a representation
		 * of the current state of node metadata.
		 *
		 * @exception std::runtime_error if a cycle is detected during included
		 * macro resolution.
		 */
		void preprocess();

		/**
		 * @brief Resolves macros that are "implicitly" included, e.g., by
		 * source files being listed before this file in the compilation list.
		 *
		 * Macro usages can be implicitly resolved iff all of:
		 *   - A macro is left unresolved from previous preprocessing steps
		 *   - Where the macro has not been resolved via an include statement
		 *   - The macro definer is in a file explicitly listed in the file list
		 *   - The macro user is a file is later in the file list
		 *
		 * After this step, the only unresolved macros should be from files
		 * that:
		 * - Do not include any modules used by the top module
		 * - Are defined via the command-line
		 *
		 * If the command-line option `--debug-out-pfx <arg>` is set, the file
		 * `{arg}_macros_resolved.log` will be created, containing a
		 * representation of the current state of node metadata.
		 */
		void implicit_macro_resolution();

		/**
		 * @brief Resolves module-based dependencies and unresolved macros.
		 *
		 * This pass uses the AST created in `prepare()` to amend the metadata
		 * created in `preprocess()` by including module-based dependencies in
		 * file dependency lists.
		 *
		 * If the command-line option `--debug-out-pfx <arg>` is set, the file
		 * `{arg}_modules_resolved.log` will be created, containing a
		 * representation of the current state of node metadata.
		 *
		 * @exception std::runtime_error if a cycle is detected during the
		 * module dependency resolution.
		 *
		 * @return A shared pointer to the SourceNode that contains the top
		 * module.
		 */
		std::shared_ptr<SourceNode> module_resolution();

		/**
		 * @brief To be run last.
		 *
		 * Produces the subset of files required to successfully compile the
		 * requested top module in reverse-topological order.
		 *
		 * @param result A reference to a container inside which the result is
		 *  emplaced.
		 *
		 * @param top_node A shared pointer to the SourceNode that contains the
		 * top module.
		 *
		 * @exception std::runtime_error if a cycle is detected during the
		 * topological sort.
		 */
		void topological_sort(
			std::vector<std::filesystem::path> &result,
			std::shared_ptr<SourceNode> top_node
		);

	private:
		// types
		enum class NodeState {
			unvisited = 0,
			visiting,
			visited,
		};
		struct ResolutionCacheEntry {
			NodeState state = NodeState::unvisited;
			std::set<std::string_view> resolved_macros;
		};
		struct Resolution {
			std::shared_ptr<SourceNode> file;
			std::set<std::string_view> resolved_macros;
		};
		struct FileEntry {};

		// methods
		Resolution process_included_macros_recursive(
			std::unordered_map<std::filesystem::path, ResolutionCacheEntry>
				&cache,
			std::shared_ptr<SourceNode> current_node
		);
		std::shared_ptr<nodo::SourceNode> process_module_dependencies_recursive(
			std::unordered_map<std::filesystem::path, NodeState> &cache,
			const slang::ast::InstanceSymbol *current_instance
		);
		bool topological_sort_recursive(
			std::vector<std::filesystem::path> &result,
			std::unordered_map<std::filesystem::path, NodeState> &node_states,
			std::shared_ptr<SourceNode> target
		);

		// helpers
		inline std::pair<slang::SourceLocation, std::filesystem::path>
		get_definition_syntax_location(
			const slang::ast::InstanceSymbol &instance
		) {
			auto loc =
				instance.getDefinition().getSyntax()->sourceRange().start();
			auto path = sourceManager.getFullPath(loc.buffer());
			return std::make_pair(std::move(loc), std::move(path));
		}

		inline void write_debug(const char *postfix) {
			if (debug_output_prefix_string.has_value()) {
				auto file = std::filesystem::path(
					*debug_output_prefix_string + postfix
				);
				std::filesystem::create_directories(file.parent_path());
				FILE *f = fopen(file.c_str(), "w");
				if (f == nullptr) {
					throw std::runtime_error(fmt::format(
						"Failed to open file '{}' for output", file.c_str()
					));
				}
				for (auto &tuple : source_nodes) {
					tuple.second->output(f);
				}
			}
		}

		// members
		std::unique_ptr<slang::ast::Compilation> compilation;
		std::unordered_map<std::filesystem::path, std::shared_ptr<SourceNode>>
			source_nodes;
		std::queue<std::pair<slang::SourceBuffer, size_t>>
			buffer_preprocessing_queue;

		// cli
		std::optional<bool> show_help;
		std::optional<bool> show_version;
		std::optional<std::string> debug_output_prefix_string;
	};
} // namespace nodo
